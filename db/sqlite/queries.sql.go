// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqlite

import (
	"context"
	"database/sql"
)

const deleteAssignment = `-- name: DeleteAssignment :exec
DELETE FROM assignments
WHERE course_id = ?1 AND id = ?2
`

type DeleteAssignmentParams struct {
	CourseID int64 `json:"course_id"`
	ID       int64 `json:"id"`
}

func (q *Queries) DeleteAssignment(ctx context.Context, arg DeleteAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteAssignment, arg.CourseID, arg.ID)
	return err
}

const deleteAssignmentsByCourse = `-- name: DeleteAssignmentsByCourse :exec
DELETE FROM assignments 
WHERE course_id = ?1
`

func (q *Queries) DeleteAssignmentsByCourse(ctx context.Context, courseID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAssignmentsByCourse, courseID)
	return err
}

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses
WHERE id = ?1
`

func (q *Queries) DeleteCourse(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCourse, id)
	return err
}

const getAssignmentCountsByCourse = `-- name: GetAssignmentCountsByCourse :many
WITH assignment_counts AS (
    SELECT course_id, COUNT(*) as total_assignments
    FROM assignments
    GROUP BY course_id
)
SELECT 
    c.id AS course_id,
    c.name AS course_name,
    COALESCE(ac.total_assignments, 0) AS assignment_count
FROM courses c
LEFT JOIN assignment_counts ac ON c.id = ac.course_id
ORDER BY assignment_count DESC
`

type GetAssignmentCountsByCourseRow struct {
	CourseID        int64  `json:"course_id"`
	CourseName      string `json:"course_name"`
	AssignmentCount int64  `json:"assignment_count"`
}

func (q *Queries) GetAssignmentCountsByCourse(ctx context.Context) ([]GetAssignmentCountsByCourseRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssignmentCountsByCourse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignmentCountsByCourseRow
	for rows.Next() {
		var i GetAssignmentCountsByCourseRow
		if err := rows.Scan(&i.CourseID, &i.CourseName, &i.AssignmentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllAssignments = `-- name: ListAllAssignments :many
SELECT id, course_id, name, due_date, created_at FROM assignments
`

func (q *Queries) ListAllAssignments(ctx context.Context) ([]Assignment, error) {
	rows, err := q.db.QueryContext(ctx, listAllAssignments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Assignment
	for rows.Next() {
		var i Assignment
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.Name,
			&i.DueDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllCourses = `-- name: ListAllCourses :many
SELECT id, name, created_at FROM courses
`

func (q *Queries) ListAllCourses(ctx context.Context) ([]Course, error) {
	rows, err := q.db.QueryContext(ctx, listAllCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsByCourse = `-- name: ListAssignmentsByCourse :many
SELECT id, name, due_date
FROM assignments
WHERE course_id = ?1
ORDER BY due_date
`

type ListAssignmentsByCourseRow struct {
	ID      int64        `json:"id"`
	Name    string       `json:"name"`
	DueDate sql.NullTime `json:"due_date"`
}

func (q *Queries) ListAssignmentsByCourse(ctx context.Context, courseID int64) ([]ListAssignmentsByCourseRow, error) {
	rows, err := q.db.QueryContext(ctx, listAssignmentsByCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssignmentsByCourseRow
	for rows.Next() {
		var i ListAssignmentsByCourseRow
		if err := rows.Scan(&i.ID, &i.Name, &i.DueDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssignment = `-- name: UpdateAssignment :exec
UPDATE assignments
SET 
    name = ?2,
    due_date = ?3
WHERE id = ?1
`

type UpdateAssignmentParams struct {
	ID      int64        `json:"id"`
	Name    string       `json:"name"`
	DueDate sql.NullTime `json:"due_date"`
}

func (q *Queries) UpdateAssignment(ctx context.Context, arg UpdateAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, updateAssignment, arg.ID, arg.Name, arg.DueDate)
	return err
}

const upsertAssignment = `-- name: UpsertAssignment :one
INSERT INTO assignments (id, course_id, name, due_date)
VALUES (?1, ?2, ?3, ?4)
ON CONFLICT(id) DO UPDATE SET 
    course_id = excluded.course_id,
    name = excluded.name,
    due_date = excluded.due_date
RETURNING id, course_id, name, due_date, created_at
`

type UpsertAssignmentParams struct {
	ID       int64        `json:"id"`
	CourseID int64        `json:"course_id"`
	Name     string       `json:"name"`
	DueDate  sql.NullTime `json:"due_date"`
}

func (q *Queries) UpsertAssignment(ctx context.Context, arg UpsertAssignmentParams) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, upsertAssignment,
		arg.ID,
		arg.CourseID,
		arg.Name,
		arg.DueDate,
	)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.Name,
		&i.DueDate,
		&i.CreatedAt,
	)
	return i, err
}

const upsertCourse = `-- name: UpsertCourse :one
INSERT INTO courses (id, name)
VALUES (?1, ?2)
ON CONFLICT(id) DO UPDATE SET 
    name = excluded.name
RETURNING id, name, created_at
`

type UpsertCourseParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

// queries.sql
func (q *Queries) UpsertCourse(ctx context.Context, arg UpsertCourseParams) (Course, error) {
	row := q.db.QueryRowContext(ctx, upsertCourse, arg.ID, arg.Name)
	var i Course
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}
