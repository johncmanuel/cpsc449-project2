// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package psql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAssignmentsByCourse = `-- name: DeleteAssignmentsByCourse :exec
DELETE FROM assignments 
WHERE course_id = $1
`

func (q *Queries) DeleteAssignmentsByCourse(ctx context.Context, courseID int32) error {
	_, err := q.db.Exec(ctx, deleteAssignmentsByCourse, courseID)
	return err
}

const getAssignmentCountsByCourse = `-- name: GetAssignmentCountsByCourse :many
WITH assignment_counts AS (
    SELECT course_id, COUNT(*) as total_assignments
    FROM assignments
    GROUP BY course_id
)
SELECT 
    c.id AS course_id,
    c.name AS course_name,
    COALESCE(ac.total_assignments, 0) AS assignment_count
FROM courses c
LEFT JOIN assignment_counts ac ON c.id = ac.course_id
ORDER BY assignment_count DESC
`

type GetAssignmentCountsByCourseRow struct {
	CourseID        int32  `json:"course_id"`
	CourseName      string `json:"course_name"`
	AssignmentCount int64  `json:"assignment_count"`
}

func (q *Queries) GetAssignmentCountsByCourse(ctx context.Context) ([]GetAssignmentCountsByCourseRow, error) {
	rows, err := q.db.Query(ctx, getAssignmentCountsByCourse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignmentCountsByCourseRow
	for rows.Next() {
		var i GetAssignmentCountsByCourseRow
		if err := rows.Scan(&i.CourseID, &i.CourseName, &i.AssignmentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsByCourse = `-- name: ListAssignmentsByCourse :many
SELECT id, name, due_date
FROM assignments
WHERE course_id = $1
ORDER BY due_date
`

type ListAssignmentsByCourseRow struct {
	ID      int32              `json:"id"`
	Name    string             `json:"name"`
	DueDate pgtype.Timestamptz `json:"due_date"`
}

func (q *Queries) ListAssignmentsByCourse(ctx context.Context, courseID int32) ([]ListAssignmentsByCourseRow, error) {
	rows, err := q.db.Query(ctx, listAssignmentsByCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssignmentsByCourseRow
	for rows.Next() {
		var i ListAssignmentsByCourseRow
		if err := rows.Scan(&i.ID, &i.Name, &i.DueDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssignment = `-- name: UpdateAssignment :exec
UPDATE assignments
SET 
    name = $2,
    due_date = $3
WHERE id = $1
`

type UpdateAssignmentParams struct {
	ID      int32              `json:"id"`
	Name    string             `json:"name"`
	DueDate pgtype.Timestamptz `json:"due_date"`
}

func (q *Queries) UpdateAssignment(ctx context.Context, arg UpdateAssignmentParams) error {
	_, err := q.db.Exec(ctx, updateAssignment, arg.ID, arg.Name, arg.DueDate)
	return err
}

const upsertAssignment = `-- name: UpsertAssignment :one
INSERT INTO assignments (id, course_id, name, due_date)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE
SET 
    course_id = EXCLUDED.course_id,
    name = EXCLUDED.name,
    due_date = EXCLUDED.due_date
RETURNING id, course_id, name, due_date, created_at
`

type UpsertAssignmentParams struct {
	ID       int32              `json:"id"`
	CourseID int32              `json:"course_id"`
	Name     string             `json:"name"`
	DueDate  pgtype.Timestamptz `json:"due_date"`
}

func (q *Queries) UpsertAssignment(ctx context.Context, arg UpsertAssignmentParams) (Assignment, error) {
	row := q.db.QueryRow(ctx, upsertAssignment,
		arg.ID,
		arg.CourseID,
		arg.Name,
		arg.DueDate,
	)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.Name,
		&i.DueDate,
		&i.CreatedAt,
	)
	return i, err
}

const upsertCourse = `-- name: UpsertCourse :one
INSERT INTO courses (id, name)
VALUES ($1, $2)
ON CONFLICT (id) DO UPDATE 
SET name = EXCLUDED.name
RETURNING id, name, created_at
`

type UpsertCourseParams struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpsertCourse(ctx context.Context, arg UpsertCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, upsertCourse, arg.ID, arg.Name)
	var i Course
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}
